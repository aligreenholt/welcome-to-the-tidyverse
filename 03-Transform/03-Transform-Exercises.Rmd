---
title: "Transform Data"
---

```{r setup}
library(tidyverse)

# Toy datasets to use

pollution <- tribble(
       ~city,   ~size, ~amount, 
  "New York", "large",      23,
  "New York", "small",      14,
    "London", "large",      22,
    "London", "small",      16,
   "Beijing", "large",      121,
   "Beijing", "small",      56
)
#changed general options to not use scientific notation
options(scipen = 999)
```

# Import Data

## Your Turn 1

Set the working directory to `03-Transform`. Then import the `babynames.csv` data set, which is in the `03-Transform` folder, as `babynames`. Then copy the import code into the code chunk below. Does it run?

```{r}
library(readr)
babynames <- read_csv("babynames.csv")
View(babynames)
```

# dplyr

## Your Turn 2

Alter the code to select just the `n` column:

```{r}
#Before
select(babynames, name, prop, n)
#After
select(babynames, n)
```

## Quiz

Which of these is NOT a way to select the `name` and `n` columns together?

```{r}
select(babynames, -c(year, sex, prop)) #TRUE
select(babynames, name:n) #TRUE
select(babynames, starts_with("n")) #TRUE
select(babynames, ends_with("n")) #FALSE
```

## Your Turn 3

Use `filter`, `babynames`, and the logical operators to find:

* All of the names where prop is greater than or equal to 0.08  
* All of the children named "Sea"  

```{r}
#Proportion is greater than or equal to 0.08
filter(babynames, prop >= 0.08)

#Children named "Sea"
filter(babynames, name == "Sea")

```

## Your Turn 4

Use Boolean operators to return only the rows that contain:

* _Boys_ named Sue  
* Names that were used by exactly 5 or 6 children in 1880  
* Names that are one of Acura, Lexus, or Yugo

```{r}
filter(babynames, sex == "M", name == "Sue")
filter(babynames, (n %in% c(5,6)) & year == 1880)
filter(babynames, name == "Acura" | name == "Lexus" | name == "Yugo")
```

## Help Me

What is the smallest value of n?
_The smallest value of n is 5._
What is the largest?
_The largest value of n is 99,686_

```{r}
arrange(babynames, n, prop)

arrange(babynames, desc(n))
```

## Your Turn 5

Use `%>%` to write a sequence of functions that: 

1. Filters babynames to just the girls that were born in 2017, *then...*  
2. Selects the `name` and `n` columns, *then...*  
3. Arranges the results so that the most popular names are near the top.

```{r}
babynames %>% 
  filter(sex == "F", year == 2017) %>% 
  select(name, n) %>% 
  arrange(desc(n))
``` 

## Your Turn 6 - Exam

1. Trim `babynames` to just the rows that contain your `name` and your `sex`  
2. Trim the result to just the columns that will appear in your graph (not strictly necessary, but useful practice)  
3. Plot the results as a line graph with `year` on the x axis and `prop` on the y axis

```{r}
babynames %>% 
  filter(name == "Ali", sex == "F") %>% 
  select(year, prop) %>% 
ggplot() +
  geom_line(mapping = aes(x = year, y = prop)) +
labs(title = "Proportion of Females Named Ali by Year, 1960-2017", 
     x = "Year", 
     y = "Proportion")
```

## Your Turn 7

Copmplete the code below to extract the rows where `name == "Khaleesi"`. Then use `summarise()` and `sum()` and `min()` to find:

1. The total number of children named Khaleesi: _1,964_
2. The first year Khaleesi appeared in the data: _2011_

*(Hint: Be sure to remove each `_` before running the code)*

```{r}
babynames %>% 
  filter(name == "Khaleesi") %>% 
  summarise(total = sum(n), first = min(year))
```

## Your Turn 8

Use `group_by()`, `summarise()`, and `arrange()` to display the ten most popular names. Compute popularity as the *total* number of children of a single gender given a name.

*(Hint: Be sure to remove each `_` before running the code)*

```{r}

babynames %>%
  group_by(name, sex) %>% 
  summarise(total = sum(n)) %>% 
  arrange(desc(total)) %>% 
  ungroup() %>% 
  slice(1:10) %>% 
  ggplot() +
  geom_col(mapping = aes(x= fct_reorder(name, desc(total)), y = total, fill=sex))+
  theme_bw() +
  scale_fill_brewer()+
  labs(x= "Name")
     
```


##Your Turn 9 

Use `group_by()` to calculate and then plot the total number of children born each year over time.

```{r}
babynames %>% 
  group_by(year) %>% 
  summarise(n_children = sum(n)) %>% 
  ggplot()+
  geom_line(mapping = aes(x=year, y=n_children))

```

## Your Turn 10

Use `mutate()` and `min_rank()`to rank each row in babynames from _largest_ n to lowest n.

*(Hint: Be sure to remove each `_` before running the code)*

```{r}
babynames %>% 
  mutate(rank = min_rank(desc(prop))) %>% 
  arrange(rank)

```

## Your Turn 11

Group babynames by **year** and then re-rank the data. Filter the results to just rows where **rank == 1**.

```{r}
babynames %>% 
  group_by(year) %>% 
  mutate(rank = min_rank(desc(prop))) %>% 
  filter(rank == 1)
```
How many years did each distinct name rank #1? 

```{r}
babynames %>% 
  group_by(year) %>% 
  mutate(rank = min_rank(desc(prop))) %>% 
  filter(rank == 1) %>%
  group_by(name) %>%
  summarise(numone = sum(rank)) %>% 
  arrange(desc(numone))

```


# Take aways

* Extract variables with `select()`  
* Extract cases with `filter()`  
* Arrange cases, with `arrange()`  

* Make tables of summaries with `summarise()`  
* Make new variables, with `mutate()`  
* Do groupwise operations with `group_by()`

* Connect operations with `%>%`  


